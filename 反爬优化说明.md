# 反爬优化说明文档

## 🎯 优化目标

解决原有设计的反爬风险问题：原实现中，获取CDN链接后立即释放并发限制，导致短时间内大量访问城通网盘页面，极易触发反爬机制。

## ✅ 已实施的优化方案

### 方案B：双重限流（平衡性能与安全）

#### 实现原理

```
原有架构（风险）：
├─ Semaphore(3) 仅控制浏览器Context
└─ Worker任务无限制并发
   └─ 获取CDN链接(3-5秒) → 释放锁 → 立即开始下一个
   └─ HTTP下载(30-300秒) → 不受任何限制

优化后架构（安全）：
├─ worker_semaphore(5) 控制整体任务并发
│  └─ 整个Worker生命周期都在保护下
│     ├─ 获取CDN链接(3-5秒)
│     │  └─ browser._semaphore(3) 控制浏览器Context
│     ├─ HTTP下载(30-300秒) ← 仍然受worker_semaphore限制
│     └─ 解压文件
└─ 确保同时最多5个任务在执行
```

#### 配置参数

```yaml
# config.yaml
browser_concurrency: 3      # 浏览器Context并发数
download_concurrency: 5     # 整体任务并发数（新增控制）
```

**推荐配置**：
- `download_concurrency` 设置为 `browser_concurrency` 的 1-2 倍
- 示例：`browser_concurrency: 3, download_concurrency: 5`

#### 效果对比

| 场景 | 原方案 | 优化后 |
|------|--------|--------|
| 下载100本书 | 20秒内完成所有页面访问 | 按下载速度控制访问频率 |
| 页面访问频率 | 每3-5秒一次 | 每20-60秒一次（取决于下载速度）|
| 反爬风险 | 🔴 极高 | 🟡 中等 |

---

### 方案C：智能延迟（模拟真人行为）

#### 实现原理

在每次浏览器访问**之前**添加随机延迟，打破规律性访问模式，模拟真实用户的操作节奏。

```python
# 伪代码
async def _worker(book):
    # 1. 智能延迟（模拟思考时间）
    await smart_delay()  # 随机等待 5-15 秒

    # 2. 访问页面获取CDN链接
    cdn_url = await browser.fetch_cdn_url(book)

    # 3. 下载文件
    await download_file(cdn_url)
```

#### 配置参数

```yaml
# config.yaml
enable_smart_delay: true    # 是否启用智能延迟（强烈建议）
request_min_delay: 5.0      # 最小间隔（秒）
request_max_delay: 15.0     # 最大间隔（秒）
```

**延迟计算逻辑**：
1. 每次访问前随机选择延迟时间：`delay = random(5.0, 15.0)`
2. 检查距离上次访问的时间间隔
3. 如果间隔不足目标延迟，补足差额
4. 首次访问无延迟（`_last_browser_access = 0`）

#### 效果对比

| 指标 | 原方案 | 优化后 |
|------|--------|--------|
| 访问间隔 | 固定3-5秒 | 随机5-15秒 |
| 行为模式 | 机械规律 | 接近真人 |
| 反爬风险 | 🔴 极高 | 🟢 低 |

---

## 📊 综合效果分析

### 下载100本书的时间对比（每本书平均下载60秒）

| 方案 | 总耗时 | 城通访问频率 | 反爬风险 | 推荐度 |
|------|--------|-------------|---------|--------|
| **原方案** | ~35分钟 | 每3-5秒 | 🔴 极高 | ✗ |
| **仅方案B** | ~50分钟 | 每20秒 | 🟡 中等 | △ |
| **仅方案C** | ~45分钟 | 每10-20秒(随机) | 🟢 低 | ○ |
| **B+C组合** | ~60分钟 | 每30-90秒(随机) | 🟢 极低 | ✓ |

### 实际执行时间线（B+C组合，download_concurrency=5）

```
时间  事件
0s    B1 开始 → 延迟 8s → 访问页面
8s    B1 开始下载 (60s)
8s    B2 开始 → 延迟 12s
20s   B2 访问页面 → 开始下载 (60s)
20s   B3 开始 → 延迟 7s
27s   B3 访问页面 → 开始下载 (60s)
27s   B4 开始 → 延迟 14s
41s   B4 访问页面 → 开始下载 (60s)
41s   B5 开始 → 延迟 9s
50s   B5 访问页面 → 开始下载 (60s)
68s   B1 完成 → B6 开始 → 延迟 11s → ...
80s   B2 完成 → B7 开始 → ...
...   持续到100本书全部完成
```

**关键改进**：
1. ✅ 访问间隔随机化，无规律可循
2. ✅ 同时最多5个任务，避免资源过载
3. ✅ 每次访问前有"思考时间"，接近真人行为

---

## 🚀 使用指南

### 1. 复制配置文件

```bash
cp config.example.yaml config.yaml
```

### 2. 调整配置参数（推荐配置）

```yaml
# config.yaml
browser_concurrency: 3      # 浏览器并发
download_concurrency: 5     # 整体任务并发（控制总体访问频率）

# 智能延迟（强烈建议启用）
enable_smart_delay: true
request_min_delay: 5.0      # 如果经常失败，可增加到 10.0
request_max_delay: 15.0     # 如果经常失败，可增加到 30.0
```

### 3. 运行下载

```bash
# 激活虚拟环境
source .venv/bin/activate

# 下载指定分类（会自动应用优化）
python -m ebook_downloader download -c AI

# 启用详细日志查看延迟效果
python -m ebook_downloader -v download -c AI
```

### 4. 观察日志

```
[INFO] 并发控制: 整体任务并发=5, 浏览器并发=3
[DEBUG] 智能延迟: 等待 8.3 秒 (目标间隔=8.3秒, 已过=0.0秒)
[INFO] 获取CDN链接: 智慧未来 → https://...
[DEBUG] 智能延迟: 等待 4.2 秒 (目标间隔=12.7秒, 已过=8.5秒)
```

---

## ⚙️ 高级调优

### 场景1：网络环境良好，希望提速

```yaml
download_concurrency: 8     # 增加并发
request_min_delay: 3.0      # 减少延迟
request_max_delay: 8.0
```

**风险**：反爬风险略有增加，建议配合代理使用。

### 场景2：经常触发反爬，需要更保守

```yaml
download_concurrency: 3     # 降低并发
request_min_delay: 10.0     # 增加延迟
request_max_delay: 30.0
```

### 场景3：使用代理池，可以适当激进

```yaml
download_concurrency: 10    # 代理轮换可以支持更高并发
request_min_delay: 3.0
request_max_delay: 10.0
proxy_api_url: https://your-proxy-api.com/...
```

### 场景4：临时测试，关闭延迟

```yaml
enable_smart_delay: false   # 仅用于调试，不建议生产使用
```

---

## 🔍 验证优化效果

### 方法1：查看日志时间戳

```bash
tail -f logs/ebook-downloader.log | grep "获取CDN链接"
```

**期望输出**：每次访问之间间隔 5-15 秒（随机）

### 方法2：统计访问频率

```bash
grep "获取CDN链接" logs/ebook-downloader.log | \
  awk '{print $1" "$2}' | \
  sort | uniq -c
```

**期望结果**：每个时间点访问数量 ≤ `download_concurrency`

### 方法3：计算实际延迟

```bash
grep "智能延迟" logs/ebook-downloader.log | \
  grep -oP '等待 \K[0-9.]+' | \
  awk '{sum+=$1; count++} END {print "平均延迟:", sum/count, "秒"}'
```

---

## 🐛 常见问题

### Q1：启用优化后下载变慢了？

**A**：这是正常现象。优化的目的是**降低反爬风险**，而非提升速度。

- 原方案：快速但高风险，容易被封
- 优化方案：稳定但较慢，长期可靠

### Q2：还是触发了反爬怎么办？

**A**：尝试以下措施（按优先级）：

1. 增加延迟：`request_max_delay: 30.0`
2. 降低并发：`download_concurrency: 3`
3. 使用代理池：`--proxy-api` 或 `--proxy-file`
4. 分批下载：`-n 10` 限制每次下载数量

### Q3：如何完全恢复到原方案？

**A**：修改配置（不推荐）：

```yaml
download_concurrency: 100   # 大于书籍总数，相当于无限制
enable_smart_delay: false
```

### Q4：延迟时间可以设置为0吗？

**A**：技术上可以，但**强烈不建议**。最小建议值：

- `request_min_delay: 3.0`（极限）
- `request_max_delay: 8.0`（极限）

---

## 📈 技术细节

### 代码修改清单

1. **config.py** (src/ebook_downloader/config.py:46-49)
   - 新增：`request_min_delay`, `request_max_delay`, `enable_smart_delay`

2. **scheduler.py** (src/ebook_downloader/scheduler.py)
   - 新增：`import random` (第7行)
   - 新增：`_last_browser_access`, `_access_lock` (第46-47行)
   - 修改：`run()` 方法，使用 `download_concurrency` 创建 `worker_semaphore` (第78行)
   - 重构：`_worker()` 方法，整个worker在semaphore保护下 (第120-133行)
   - 新增：`_download_book()` 方法，提取下载逻辑 (第135-232行)
   - 新增：`_smart_delay()` 方法，实现智能延迟 (第234-266行)

3. **config.example.yaml**
   - 新增：方案B和方案C的配置说明和示例

### 向后兼容性

✅ **完全兼容**：
- 不修改配置文件时，使用默认值（已启用优化）
- CLI参数保持不变
- 数据库结构无变化

---

## 📝 总结

| 优化方案 | 实现难度 | 性能影响 | 反爬效果 | 推荐指数 |
|---------|---------|---------|---------|---------|
| 方案B：双重限流 | ⭐⭐ | -30% | ⭐⭐⭐ | ⭐⭐⭐⭐ |
| 方案C：智能延迟 | ⭐ | -20% | ⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ |
| B+C组合 | ⭐⭐ | -50% | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ |

**最终建议**：使用 B+C 组合（已默认启用），配合适度的并发和延迟参数，可实现**高稳定性**和**低反爬风险**的平衡。
